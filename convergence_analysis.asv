%Example template for analysis function
%INPUTS:
%solver_flag: an integer from 1-4 indicating which solver to use
% 1->Bisection 2-> Newton 3->Secant 4->fzero
%fun: the mathematical function that we are using the
% solver to compute the root of
%x_guess0: the initial guess used to compute x_root
%guess_list1: a list of initial guesses for each trial
%guess_list2: a second list of initial guesses for each trial
% if guess_list2 is not needed, then set to zero in input
%filter_list: a list of constants used to filter the collected data
function convergence_analysis(solver_flag, fun, ...
    x_guess0, guess_list1, guess_list2, filter_list)

    e_n0 = [];
    e_n1 = [];
    guess_it = [];
    
    for i = 1:200
        x_left = randi([-30, -5]);
        x_right = randi([5, 30]);

        % Check if the solver_flag is valid and call the appropriate solver
        switch solver_flag
            case 1
                [root, x0, x1, guess_it] = bisection_solver(@fun, x_left, x_right);
            case 2
                [root, guess_it] = newton_solver(@fun, x_guess0);
            case 3
                [root, guess_it] = secant_solver(@fun, x_left, x_right);
            case 4
                root = fzero(@fun, x_guess0);
            otherwise
                error('Invalid solver_flag. Must be an integer from 1 to 4.');
        end

        x_root = bisection_solver(@fun, x_left, x_right); % setting true root as root found via bisection, can replace with any other method if desired. fzero yields exact same precision result
    
        e_n0 = [e_n0 abs(x0-x_root)];
        e_n1 = [e_n1 abs(x1-x_root)];
        guess_it = [guess_it bi_guess_it];
    end

    fprintf('The root found is: %.14f\n', bi_root);

    loglog(e_n0,e_n1,'ro','markerfacecolor','r','markersize',1); %loglog sanity check
    hold on;

    %example for how to filter the error data
    %currently have error_list0, error_list1, index_list
    %data points to be used in the regression
    x_regression = []; % e_n
    y_regression = []; % e_{n+1}
    %iterate through the collected data
    for n=1:length(guess_it)
         %if the error is not too big or too small
         %and it was enough iterations into the trial...
         if e_n0(n)>1e-15 && e_n0(n)<1e-2 && ...
            e_n1(n)>1e-14 && e_n1(n)<1e-2 && ...
            guess_it(n)>2
            %then add it to the set of points for regression
            x_regression(end+1) = e_n0(n);
            y_regression(end+1) = e_n1(n);
        end
    end

    [p, k] = generate_error_fit(x_regression, y_regression);
    %example for how to plot fit line
    %generate x data on a logarithmic range
    fit_line_x = 10.^(-16:.01:1);
    %compute the corresponding y values
    fit_line_y = k*fit_line_x.^p;
    %plot on a loglog plot.
    loglog(fit_line_x,fit_line_y,'k-','linewidth',2)
    p
    k

end

function [f, dfdx] = fun(x)
    f =  (x.^3)/100 - (x.^2)/8 + 2*x + 6*sin(x/2+6) - 0.7 - exp(x/6);
    dfdx =  (3*x.^2)/100 - (x)/4 + 2 + 3*cos(x/2 + 6)*0.5 - (1/6)*exp(x/6);
end

%example for how to compute the fit line
%data points to be used in the regression
%x_regression -> e_n
%y_regression -> e_{n+1}
%p and k are the output coefficients

function [p,k] = generate_error_fit(x_regression,y_regression)
    %generate Y, X1, and X2
    %note that I use the transpose operator (')
    %to convert the result from a row vector to a column
    %If you are copy-pasting, the ' character may not work correctly
    Y = log(y_regression)';
    X1 = log(x_regression)';
    X2 = ones(length(X1),1);
    %run the regression
    coeff_vec = regress(Y,[X1,X2]);
    %pull out the coefficients from the fit
    p = coeff_vec(1);
    k = exp(coeff_vec(2));
end

%example of how to implement finite difference approximation
%for the first and second derivative of a function
%INPUTS:
%fun: the mathetmatical function we want to differentiate
%x: the input value of fun that we want to compute the derivative at
%OUTPUTS:
%dfdx: approximation of fun'(x)
%d2fdx2: approximation of fun''(x)
function [dfdx,d2fdx2] = approximate_derivative(fun,x)
    %set the step size to be tiny
    delta_x = 1e-6;
    %compute the function at different points near x
    f_left = fun(x-delta_x);
    f_0 = fun(x);
    f_right = fun(x+delta_x);
    %approximate the first derivative
    dfdx = (f_right-f_left)/(2*delta_x);
    %approximate the second derivative
    d2fdx2 = (f_right-2*f_0+f_left)/(delta_x^2);
end